11月18日： 将Interest的逻辑状态机写完了，还没测试。
先把CSLRU类里面的构造函数中加上一些mock的content保证Content Store中是有东西的。然后才能进行测试。

11月19日：
我把Data的状态机写好了，但是还没测试。
我把测试的client迁移到110这台机器了，否则会出现重复回传的问题。

11月20日：
Interest和Data的状态机都写好了，在关键部分都加上了锁．
在110机器起了一个客户端，完成了测试．

11月21日：
我调研了一下具体的数据命名，<清华大学>83页写的：ContentName作为数据内容的唯一标识，是由数据的发布者自行决定如何命名，只需要和请求端的应用程序命名遵循同样的约定即可．
Contentname的最后一个部分segment2这种是用来标识这个数据包是原始文件中的第几块的，这样可以方便应用程序按照递增顺序查找数据包并在接收后按照顺序进行合并

我需要改一下Content Store的设计．
对于content store里面，最小的结构单元应该是包，但是请求应该是以文件的形式请求．
比如说客户端如果要请求一个文件：file/test1.txt／v1　那么直接发送Interest请求pku/eecs/file/test1.txt/v1 就好了．
但是在实际接收的时候，服务层和ICN节点会接收到诸如pku/eecs/file/test1.txt/v1／segment1之类的数据包,那么根据PIT中最长匹配原则匹配到的上层目录（pku/eecs/file/test1.txt/v1）对应的请求源端就可以找到应该把此data转发到那些端口了．

在接收层面．应该能够对某个收到的文件包进行排序，data包应该设置一位是否为end末尾，来帮助此线程进行排序整理．如果发现缺少某些包，那么应该可以重新传输．
那么由上面的机制，CS 表的设计应该进行修改．也就是以文件的粒度进行lru而不是以包的形式．也就是保证一个文件下面的所有包，要不然都被替换抛弃，要不然就都留着．也就是说，一个testfile.txt/v1　下面的１０个包，要不然都留着，要不然都被testfile2.txt／v1 下面的５个包替换掉．
这个明天改一下．
此外还有FIB的路由机制也需要改，因为在用户看来，Interest包只有file/test1.txt／v1　这种类似的请求了，不包含什么GEO_1，那么对于第二层ICN网络，其实只需要周围找一圈,如果没用，那么重新向上找．对于第一级，如果没用，则直接向用户进行请求就完事了．

11月23日：
我按照上面的修改逻辑，改到了　InterestProc.cpp 67行　//在content Store中没有找到

11月26日
高轨卫星的星间链路：首先高轨星间链路不应该是一个网状网络，应该是一个环状网络，并不是所有GEO之间都能互通．
如果说一个轨道三颗星，那么两颗星之间的链路(120度角)比GEO到地面的链路还要长．如果像北斗一样是５颗星座，那么星间链路的长度和GEO到地面的长度是一样的．
再考虑到文件请求内容的相似性，相同的文件内容很有可能只有这个区域的用户会请求
所以对于高轨卫星，他只需要询问周围的左右两颗卫星即可，如果有，直接向其发送Interest包;如果没有，则向上级发送Interest包．
－－－－－－－－－－－－－
而对于地面网状网络的ICN节点，情况就不同了．因为地面网状网络是相通的，所以可以轮询地面的所有的ICN节点，如果没有，再交给上级，也就是客户端

11月30日
目前CS和PIT的单测写好了．　FIB不同层的转发逻辑还没写．
目前改到InterestProc的７０行：　vector<string> pendingFace = getForwardingFaces(name);

12月2日：
InterestProc把同级请求超时写好了，还没测试

12月3日：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
本日计划：将InterestProc测试完毕

12月６日
在63 235 247ICN　节点上搭建了docker测试完毕
下一步需要讨论以下PIT表的删除

12月７日计划:
测试Interest包对于包粒度的Interest请求的回应
PIT表的删除
--------------
今天发现的一个问题是：对于一个Interest请求，如果先发送的是包粒度，后发送的是文件粒度，那么就会有问题
但是这种情况比较少，因为通常都是先发送文件粒度，然后包粒度用于查缺补漏的，所以可以先忽略

1月９日计划
新线程处理视频流，ICN节点起到转发的作用

1月15日计划：
当前完成的是ICN信息中心网络本身的　发布/订阅　范式．　发端无视收端是谁和在哪，直接可以将文件，视频和短消息发送给ICN节点上．　收端无视发端是谁和在哪，直接向ICN提交订阅请求即可．
但是考虑到传统信息发布平台支持的推送模式，基于ICN网络的信息发布平台也应该支持.

在推送模式下，发布者和ICN节点说源在哪里，ICN节点取源端取数据．推送模式下，发布者还会告诉ICN节点本次数据源对应的单个订阅者和订阅组都有哪些．ICN取得数据之后，就将数据推送给所有订阅组的订阅者.
在推送模式下，当ICN节点查询发现本节点有数据的时候就直接进行推送;
当发现没有数据的时候则进行引接，引接相当于从数据源取数据，取完数据进行发送

1月21号
现在来看，PIT表的逻辑有一些地方需要完善

2月15日:
当前完成了组播的高层节点的逻辑修改:
对于高层节点读到了组播地址之后，应该换成下层节点的单播地址避免多个节点向组播发送数据造成重复
主要修改在PIT.cpp　增加了对fib表的依赖，从而获得下层节点的单播地址
